<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js VR Scene</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #renderCanvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = function() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.7, 0.8, 1); // Blue sky
            const gl = new BABYLON.GlowLayer("glow", scene);

            // Camera
            const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 5, -10), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(canvas, true);

            // Enable fog in the scene
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2; // Exponential squared fog
            scene.fogColor = new BABYLON.Color3(0.7, 0.8, 1); // Match the sky color
            scene.fogDensity = 0.0008; // Adjust density for the desired effect


            // Light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            // Add a directional light to simulate sunlight
            const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            directionalLight.position = new BABYLON.Vector3(50, 100, 50);
            directionalLight.intensity = 1.0;

            // Ground (infinite plane)
            const ground = BABYLON.Mesh.CreatePlane("ground", 10000, scene); // Make it very large
            ground.rotation.x = Math.PI / 2;

            // Ground Material
            const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0, 0.8, 0); // Green
            groundMaterial.backFaceCulling = false; // Ensure both sides are rendered
            ground.material = groundMaterial;

            // Ensure the ground receives light
            ground.receiveShadows = true;

            // Sun (a simple sphere)
            const sun = BABYLON.Mesh.CreateSphere("sun", 320, 200, scene);
            sun.position = new BABYLON.Vector3(1000, 1000, 0);
            const sunMaterial = new BABYLON.StandardMaterial("sunMaterial", scene);
            sunMaterial.emissiveColor = new BABYLON.Color3(1, 1, 0.6); // Bright yellow-white
            sunMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0.8); // Match emissive
            sunMaterial.specularColor = new BABYLON.Color3(1, 1, 0.8); // Add specular highlights
            sunMaterial.ambientColor = new BABYLON.Color3(1, 1, 0.8); // Add ambient glow
            sunMaterial.disableLighting = true; // Make it unaffected by scene lighting
            sunMaterial.alpha = 1.0; // Ensure full opacity
            sun.material = sunMaterial;
            gl.addIncludedOnlyMesh(sun);


            // Add a glow effect to the sun
            const sunGlow = BABYLON.Mesh.CreateSphere("sunGlow", 340, 200, scene);
            sunGlow.position = sun.position;
            const sunGlowMaterial = new BABYLON.StandardMaterial("sunGlowMaterial", scene);
            sunGlowMaterial.emissiveColor = new BABYLON.Color3(1, 1, 0.4); // Yellow glow
            sunGlowMaterial.alpha = 0.3; // Make it semi-transparent
            sunGlowMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
            sunGlowMaterial.disableLighting = true; // Make it unaffected by scene lighting
            sunGlow.material = sunGlowMaterial;

            light.includedOnlyMeshes.push(sun); // Ensure the sun casts light

           // Clouds (using points and billboards for simplicity)
            const cloudPoints = [];
            const numClouds = 500;

            for (let i = 0; i < numClouds; i++) {
                cloudPoints.push({
                    position: new BABYLON.Vector3(
                        Math.random() * 5000 - 2500, // x (spread clouds across a wider range)
                        Math.random() * 300 + 200,  // y (adjust height range)
                        Math.random() * 5000 - 2500 // z (spread clouds across a wider range)
                    ),
                    size: Math.random() * 100 + 50, // Increased size range
                });
            }

            const cloudGeometry = BABYLON.Mesh.CreatePlane("cloud", 1, scene, false, BABYLON.Mesh.DOUBLESIDE);
            cloudGeometry.visibility = 0;

            for (let i = 0; i < numClouds; i++) {
                const cloud = cloudGeometry.clone("cloud" + i); // Use clone instead of createInstance
                cloud.position = cloudPoints[i].position;
                cloud.scaling = new BABYLON.Vector3(cloudPoints[i].size, cloudPoints[i].size, cloudPoints[i].size);
                cloud.rotation.x = Math.PI / 2;
                cloud.visibility = 1; // Ensure the cloud is visible

                const cloudMaterial = new BABYLON.StandardMaterial("cloudMaterial" + i, scene);
                cloudMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1); // Bright white color
                cloudMaterial.alpha = 0.5; // Adjust transparency
                cloudMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; // Enable alpha blending
                cloudMaterial.backFaceCulling = true; // Render both sides of the plane
                cloud.material = cloudMaterial;
            }

            // WebXR Default Experience
            BABYLON.WebXRDefaultExperience.CreateAsync(scene).then((xr) => {
                console.log("WebXR enabled");
                
                // Create a variable to track if the game has started
                let gameStarted = false;
                
                // Variable to store the airplane root mesh
                let airplaneRoot = null;
                
                // Add teleportation and basic VR setup
                const featuresManager = xr.baseExperience.featuresManager;
                
                // Enable required WebXR features
                featuresManager.enableFeature(BABYLON.WebXRFeatureName.POINTER_SELECTION, "stable", {
                    xrInput: xr.input,
                    enablePointerSelectionOnAllControllers: true
                });

                // Create start button that will be visible in VR
                xr.baseExperience.onStateChangedObservable.add((state) => {
                    if (state === BABYLON.WebXRState.IN_XR) {
                        // Create button when VR session starts
                        const startButtonPlane = BABYLON.MeshBuilder.CreatePlane("startButton", {width: 1, height: 0.5}, scene);
                        startButtonPlane.position = new BABYLON.Vector3(0, 1, -8); // Better position in front of user
                        
                        // Create a dark gray material for the button
                        const buttonMaterial = new BABYLON.StandardMaterial("buttonMaterial", scene);
                        buttonMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Dark gray
                        buttonMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Subtle glow
                        buttonMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3); // More prominent specular
                        startButtonPlane.material = buttonMaterial;
                        
                        // Add text to the button
                        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(startButtonPlane);
                        
                        // Create a dark gray background rectangle
                        const backgroundRect = new BABYLON.GUI.Rectangle();
                        backgroundRect.width = 0.9;
                        backgroundRect.height = 0.8;
                        backgroundRect.cornerRadius = 20;
                        backgroundRect.color = "white";
                        backgroundRect.thickness = 2;
                        backgroundRect.background = "#333333"; // Dark gray background
                        advancedTexture.addControl(backgroundRect);
                        
                        const buttonText = new BABYLON.GUI.TextBlock();
                        buttonText.text = "START GAME";
                        buttonText.color = "white";
                        buttonText.fontSize = 160; // Even larger font
                        buttonText.outlineWidth = 3; // Thicker outline
                        buttonText.outlineColor = "black";
                        advancedTexture.addControl(buttonText);
                        
                        // Create button animation to make it more noticeable
                        const frameRate = 30;
                        const easingFunction = new BABYLON.SineEase();
                        easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
                        
                        const scaleAnim = new BABYLON.Animation("buttonScale", "scaling", frameRate, 
                            BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                        
                        const keyFrames = []; 
                        keyFrames.push({frame: 0, value: new BABYLON.Vector3(1, 1, 1)});
                        keyFrames.push({frame: frameRate, value: new BABYLON.Vector3(1.1, 1.1, 1.1)});
                        keyFrames.push({frame: 2 * frameRate, value: new BABYLON.Vector3(1, 1, 1)});
                        
                        scaleAnim.setKeys(keyFrames);
                        scaleAnim.setEasingFunction(easingFunction);
                        startButtonPlane.animations = [scaleAnim];
                        scene.beginAnimation(startButtonPlane, 0, 2 * frameRate, true);
                        
                        // Function to load the airplane
                        const loadAirplane = () => {
                            if (gameStarted) return; // Don't load again if already started
                            
                            gameStarted = true;
                            buttonMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); // Gray out the button
                            buttonText.text = "GAME STARTED";
                            
                            // Stop the animation
                            scene.stopAnimation(startButtonPlane);
                            startButtonPlane.dispose();
                            
                            // Load the airplane model
                            BABYLON.SceneLoader.ImportMesh("", "resources/airplane/", "airplane.obj", scene, function (meshes) {
                                // Assume the first mesh is the main airplane body
                                airplaneRoot = meshes[0];
                                airplaneRoot.scaling = new BABYLON.Vector3(0.0004, 0.0004, 0.0004); // Apply scaling to the root
                                airplaneRoot.castShadows = false; // Disable shadows for the root

                                // Set the rotation offsets in degrees for all three axes
                                const rotationOffsetX = 90; // Rotation around X-axis (pitch)
                                const rotationOffsetY = 180;  // Rotation around Y-axis (yaw)
                                const rotationOffsetZ = 90;  // Rotation around Z-axis (roll)
                                
                                // Create a custom material for the airplane body
                                const airplaneMaterial = new BABYLON.StandardMaterial("airplaneMaterial", scene);
                                airplaneMaterial.diffuseTexture = new BABYLON.Texture("resources/airplane/blue_airplane_texture.jpg", scene);
                                airplaneMaterial.specularColor = new BABYLON.Color3(1.2, 1.2, 1.2);
                                airplaneMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                                airplaneMaterial.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);

                                // Create a custom material for the windows
                                const windowMaterial = new BABYLON.StandardMaterial("windowMaterial", scene);
                                windowMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.7, 1.0); // Light blue color
                                windowMaterial.alpha = 0.7; // Make windows slightly transparent
                                windowMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Add some reflectivity

                                // Apply material and settings to all loaded meshes
                                meshes.forEach(mesh => {
                                    mesh.castShadows = false; // Disable shadows for all parts
                                    if (mesh === airplaneRoot) {
                                        mesh.material = airplaneMaterial; // Apply body material to the root
                                    } else {
                                        mesh.material = windowMaterial; // Apply window material to other parts
                                        mesh.parent = airplaneRoot; // Parent child meshes to the root
                                    }
                                });
                                
                                // Set up hand tracking for the root mesh
                                const controllerTracker = scene.onBeforeRenderObservable.add(() => {
                                    // Look for the right controller
                                    const rightController = xr.input.controllers.find(
                                        controller => controller.inputSource.handedness === 'right'
                                    );
                                    
                                    // If we have both the controller and the airplane
                                    if (rightController && rightController.pointer && airplaneRoot) {
                                        // Update position of the root mesh
                                        airplaneRoot.position = rightController.pointer.position;
                                        
                                        // Update rotation of the root mesh
                                        if (rightController.pointer.rotationQuaternion) {
                                            // Create a new quaternion to avoid reference issues
                                            airplaneRoot.rotationQuaternion = rightController.pointer.rotationQuaternion.clone();
                                            
                                            // Add rotations around all three axes
                                            const rotationX = BABYLON.Quaternion.RotationAxis(
                                                BABYLON.Vector3.Right(),
                                                BABYLON.Tools.ToRadians(rotationOffsetX)
                                            );
                                            const rotationY = BABYLON.Quaternion.RotationAxis(
                                                BABYLON.Vector3.Up(),
                                                BABYLON.Tools.ToRadians(rotationOffsetY)
                                            );
                                            const rotationZ = BABYLON.Quaternion.RotationAxis(
                                                BABYLON.Vector3.Forward(),
                                                BABYLON.Tools.ToRadians(rotationOffsetZ)
                                            );
                                            
                                            // Combine all rotations
                                            airplaneRoot.rotationQuaternion = airplaneRoot.rotationQuaternion
                                                .multiply(rotationX)
                                                .multiply(rotationY)
                                                .multiply(rotationZ);
                                        }
                                    }
                                });

                                // Add camera movement based on hand direction
                                const cameraMovementSpeed = 2; // Adjust speed as needed
                                const cameraMovement = scene.onBeforeRenderObservable.add(() => {
                                    // Only move camera if game has started
                                    if (!gameStarted) return;
                                    
                                    // Look for the right controller (same as airplane control)
                                    const rightController = xr.input.controllers.find(
                                        controller => controller.inputSource.handedness === 'right'
                                    );
                                    
                                    if (rightController && rightController.pointer) {
                                        if (rightController.pointer.rotationQuaternion) {
                                            // Get the current camera position from the XR camera
                                            const xrCamera = xr.baseExperience.camera;
                                            
                                            // Create a temporary matrix to extract Euler angles
                                            const tempMatrix = new BABYLON.Matrix();
                                            rightController.pointer.rotationQuaternion.toRotationMatrix(tempMatrix);
                                            const rotation = BABYLON.Vector3.Zero();
                                            tempMatrix.decompose(BABYLON.Vector3.Zero(), rotation);
                                            
                                            // Extract pitch, yaw, roll in radians
                                            const pitch = rotation.x; // X rotation (up/down)
                                            const yaw = rotation.y;   // Y rotation (left/right)
                                            const roll = rotation.z;  // Z rotation (banking)
                                            
                                            // Create movement direction based on hand orientation
                                            // Forward direction is always present (constant forward movement)
                                            const forwardVector = new BABYLON.Vector3(0, 0, 1);
                                            const forwardDirection = new BABYLON.Vector3();
                                            forwardVector.rotateByQuaternionToRef(
                                                rightController.pointer.rotationQuaternion,
                                                forwardDirection
                                            );
                                            
                                            // Calculate movement vector based on plane physics:
                                            // 1. Pitch controls up/down movement
                                            // 2. Yaw controls left/right turning
                                            // 3. Roll (banking) influences turning
                                            
                                            // Calculate final movement direction
                                            // Start with forward movement
                                            const movementDirection = forwardDirection.clone();
                                            
                                            // Apply pitch influence (up/down)
                                            // Pitch forward (negative) moves down, pitch back (positive) moves up
                                            movementDirection.y += Math.sin(pitch) * 0.8;
                                            
                                            // Apply yaw influence (left/right turning)
                                            // Direct yaw influence
                                            const yawFactor = Math.sin(yaw) * 0.4;
                                            movementDirection.x += yawFactor;
                                            
                                            // Apply roll influence (banking causes turning)
                                            // Banking left (negative roll) turns left, banking right (positive roll) turns right
                                            // Make roll the primary turning mechanism, with a stronger influence
                                            // Use a non-linear response curve for more natural control
                                            let rollResponse;
                                            if (Math.abs(roll) < 0.3) {
                                                // More sensitive at small angles for fine control
                                                rollResponse = roll * 2.5;
                                            } else {
                                                // Gradually less sensitive at larger angles to prevent over-control
                                                const direction = Math.sign(roll);
                                                rollResponse = direction * (0.75 + Math.min(Math.abs(roll), 1.5) * 0.5);
                                            }
                                            const rollFactor = -rollResponse * 1.5;
                                            movementDirection.x += rollFactor;
                                            
                                            // Apply coordinated turn physics - banking affects vertical movement
                                            // When banking, we need to pull up slightly to maintain altitude in a turn
                                            // This simulates how pilots handle coordinated turns
                                            if (Math.abs(roll) > 0.1) {
                                                // The steeper the bank angle, the more we need to pull up to maintain altitude
                                                const bankCorrection = Math.abs(roll) * 0.3;
                                                movementDirection.y += bankCorrection;
                                            }
                                            
                                            // Make roll also affect forward/back direction slightly
                                            // This simulates how banking an aircraft affects its flight path in a curve
                                            if (Math.abs(roll) > 0.2) {
                                                const rollMagnitude = Math.abs(roll);
                                                // Roll also slightly affects forward movement
                                                movementDirection.z -= (rollMagnitude - 0.2) * 0.3;
                                            }
                                            
                                            // Add a bit of natural lift/drag simulation
                                            // Slight upward tendency unless pitched down strongly
                                            if (pitch > -0.3) {
                                                movementDirection.y += 0.05;
                                            }
                                            
                                            // Normalize the direction
                                            movementDirection.normalize();
                                            
                                            // Get throttle value - how far the controller is tilted forward
                                            // More forward tilt (negative pitch) gives more throttle
                                            // Limited to a reasonable range
                                            let throttle = cameraMovementSpeed;
                                            if (pitch < 0) {
                                                // Forward tilt increases speed (up to 2x speed at full forward tilt)
                                                throttle = cameraMovementSpeed * (1 + Math.min(Math.abs(pitch), 1));
                                            } else {
                                                // Backward tilt reduces speed (down to 0.5x speed at full backward tilt)
                                                throttle = cameraMovementSpeed * (1 - Math.min(pitch * 0.5, 0.5));
                                            }
                                            
                                            // Move the camera without rotating it
                                            xrCamera.position.addInPlace(
                                                movementDirection.scale(throttle)
                                            );
                                            
                                            // Safety limits: prevent going below ground level
                                            const minimumHeight = 1.0; // Minimum height above ground
                                            if (xrCamera.position.y < minimumHeight) {
                                                xrCamera.position.y = minimumHeight;
                                            }
                                        }
                                    }
                                });

                                // Remove both observers when the scene disposes
                                scene.onDisposeObservable.add(() => {
                                    if (controllerTracker) {
                                        scene.onBeforeRenderObservable.remove(controllerTracker);
                                    }
                                    if (cameraMovement) {
                                        scene.onBeforeRenderObservable.remove(cameraMovement);
                                    }
                                });
                            });
                        };
                        
                        // Set up Near Interaction
                        startButtonPlane.isPickable = true;
                        
                        // Add interactions to the button (for VR controllers)
                        startButtonPlane.actionManager = new BABYLON.ActionManager(scene);
                        startButtonPlane.actionManager.registerAction(
                            new BABYLON.ExecuteCodeAction(
                                BABYLON.ActionManager.OnPickTrigger,
                                loadAirplane
                            )
                        );
                    }
                });
            });

            return scene;
        };

        const scene = createScene();

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
